{"version":3,"sources":["js/hoverEffect.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA","file":"hoverEffect.5e7172bf.js","sourceRoot":"..\\src","sourcesContent":["// var hoverEffect = function (opts) {\r\n// \tvar THREE = window.THREE;\r\n// \tvar vertex = `\r\n// varying vec2 vUv;\r\n// void main() {\r\n//   vUv = uv;\r\n//   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n// }\r\n// `;\r\n\r\n// \tvar fragment = `\r\n// varying vec2 vUv;\r\n// uniform float dispFactor;\r\n// uniform sampler2D disp;\r\n// uniform sampler2D texture1;\r\n// uniform sampler2D texture2;\r\n// uniform float angle1;\r\n// uniform float angle2;\r\n// uniform float intensity1;\r\n// uniform float intensity2;\r\n// mat2 getRotM(float angle) {\r\n//   float s = sin(angle);\r\n//   float c = cos(angle);\r\n//   return mat2(c, -s, s, c);\r\n// }\r\n// void main() {\r\n//   vec4 disp = texture2D(disp, vUv);\r\n//   vec2 dispVec = vec2(disp.r, disp.g);\r\n//   vec2 distortedPosition1 = vUv + getRotM(angle1) * dispVec * intensity1 * dispFactor;\r\n//   vec2 distortedPosition2 = vUv + getRotM(angle2) * dispVec * intensity2 * (1.0 - dispFactor);\r\n//   vec4 _texture1 = texture2D(texture1, distortedPosition1);\r\n//   vec4 _texture2 = texture2D(texture2, distortedPosition2);\r\n//   gl_FragColor = mix(_texture1, _texture2, dispFactor);\r\n// }\r\n// `;\r\n\r\n// \tfunction firstDefined() {\r\n// \t\tfor (var i = 0; i < arguments.length; i++) {\r\n// \t\t\tif (arguments[i] !== undefined) return arguments[i];\r\n// \t\t}\r\n// \t}\r\n\r\n// \tvar parent = opts.parent;\r\n// \tvar dispImage = opts.displacementImage;\r\n// \tvar image1 = opts.image1;\r\n// \tvar image2 = opts.image2;\r\n// \tvar intensity1 = firstDefined(opts.intensity1, opts.intensity, 1);\r\n// \tvar intensity2 = firstDefined(opts.intensity2, opts.intensity, 1);\r\n// \tvar commonAngle = firstDefined(opts.angle, Math.PI / 4); // 45 degrees by default, so grayscale images work correctly\r\n// \tvar angle1 = firstDefined(opts.angle1, commonAngle);\r\n// \tvar angle2 = firstDefined(opts.angle2, -commonAngle * 3);\r\n// \tvar speedIn = firstDefined(opts.speedIn, opts.speed, 1.6);\r\n// \tvar speedOut = firstDefined(opts.speedOut, opts.speed, 1.2);\r\n// \tvar userHover = firstDefined(opts.hover, true);\r\n// \tvar easing = firstDefined(opts.easing, Expo.easeOut);\r\n\r\n// \tif (!parent) {\r\n// \t\tconsole.warn('Parent missing');\r\n// \t\treturn;\r\n// \t}\r\n\r\n// \tif (!(image1 && image2 && dispImage)) {\r\n// \t\tconsole.warn('One or more images are missing');\r\n// \t\treturn;\r\n// \t}\r\n\r\n// \tvar scene = new THREE.Scene();\r\n// \tvar camera = new THREE.OrthographicCamera(\r\n// \t\tparent.offsetWidth / -2,\r\n// \t\tparent.offsetWidth / 2,\r\n// \t\tparent.offsetHeight / 2,\r\n// \t\tparent.offsetHeight / -2,\r\n// \t\t1,\r\n// \t\t1000\r\n// \t);\r\n\r\n// \tcamera.position.z = 1;\r\n\r\n// \tvar renderer = new THREE.WebGLRenderer({ antialias: false });\r\n\r\n// \trenderer.setPixelRatio(window.devicePixelRatio);\r\n// \trenderer.setClearColor(0xffffff, 0.0);\r\n// \trenderer.setSize(parent.offsetWidth, parent.offsetHeight);\r\n// \tparent.appendChild(renderer.domElement);\r\n\r\n// \tvar render = function () {\r\n// \t\t// This will be called by the TextureLoader as well as TweenMax.\r\n// \t\trenderer.render(scene, camera);\r\n// \t};\r\n\r\n// \tvar loader = new THREE.TextureLoader();\r\n// \tloader.crossOrigin = '';\r\n// \tvar texture1 = loader.load(image1, render);\r\n// \tvar texture2 = loader.load(image2, render);\r\n// \tvar disp = loader.load(dispImage, render);\r\n// \tdisp.wrapS = disp.wrapT = THREE.RepeatWrapping;\r\n\r\n// \ttexture1.magFilter = texture2.magFilter = THREE.LinearFilter;\r\n// \ttexture1.minFilter = texture2.minFilter = THREE.LinearFilter;\r\n\r\n// \tvar mat = new THREE.ShaderMaterial({\r\n// \t\tuniforms: {\r\n// \t\t\tintensity1: { type: 'f', value: intensity1 },\r\n// \t\t\tintensity2: { type: 'f', value: intensity2 },\r\n// \t\t\tdispFactor: { type: 'f', value: 0.0 },\r\n// \t\t\tangle1: { type: 'f', value: angle1 },\r\n// \t\t\tangle2: { type: 'f', value: angle2 },\r\n// \t\t\ttexture1: { type: 't', value: texture1 },\r\n// \t\t\ttexture2: { type: 't', value: texture2 },\r\n// \t\t\tdisp: { type: 't', value: disp },\r\n// \t\t},\r\n\r\n// \t\tvertexShader: vertex,\r\n// \t\tfragmentShader: fragment,\r\n// \t\ttransparent: true,\r\n// \t\topacity: 1.0,\r\n// \t});\r\n\r\n// \tvar geometry = new THREE.PlaneBufferGeometry(parent.offsetWidth, parent.offsetHeight, 1);\r\n// \tvar object = new THREE.Mesh(geometry, mat);\r\n// \tscene.add(object);\r\n\r\n// \tfunction transitionIn() {\r\n// \t\tTweenMax.to(mat.uniforms.dispFactor, speedIn, {\r\n// \t\t\tvalue: 1,\r\n// \t\t\tease: easing,\r\n// \t\t\tonUpdate: render,\r\n// \t\t\tonComplete: render,\r\n// \t\t});\r\n// \t}\r\n\r\n// \tfunction transitionOut() {\r\n// \t\tTweenMax.to(mat.uniforms.dispFactor, speedOut, {\r\n// \t\t\tvalue: 0,\r\n// \t\t\tease: easing,\r\n// \t\t\tonUpdate: render,\r\n// \t\t\tonComplete: render,\r\n// \t\t});\r\n// \t}\r\n\r\n// \tif (userHover) {\r\n// \t\tparent.addEventListener('mouseenter', transitionIn);\r\n// \t\tparent.addEventListener('touchstart', transitionIn);\r\n// \t\tparent.addEventListener('mouseleave', transitionOut);\r\n// \t\tparent.addEventListener('touchend', transitionOut);\r\n// \t}\r\n\r\n// \twindow.addEventListener('resize', function (e) {\r\n// \t\trenderer.setSize(parent.offsetWidth, parent.offsetHeight);\r\n// \t});\r\n\r\n// \tthis.next = transitionIn;\r\n// \tthis.previous = transitionOut;\r\n// };"]}